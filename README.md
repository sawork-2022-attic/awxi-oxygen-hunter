# awXI 针对 IDA Pro 的调研报告

DZ21330014

## IDA Pro 简介

首先，简要介绍一下 IDA Pro 的功能、特点和地位。

IDA Pro 的全称是 Interactive Disassembler Professional（交互式反汇编器专业版），它是一款代码逆向软件，可以将二进制程序进行反汇编，恢复出类 C 语言源码。

IDA Pro 具有交互式的，可编程的，可扩展的，多处理器等特点， 被公认为最好的花钱可以买到的逆向工程利器。它支持数十种CPU指令集其中包括 Intel x86，x64，MIPS，PowerPC，ARM，Z80，68000，c8051 等等。



下面的内容将按如下思路展开：

- 为什么我们需要代码逆向？

- 一个实用的代码逆向工具应该具备哪些功能？
- IDA Pro 是如何支持这些功能的？
- IDA Pro 的设计哲学



## 需求分析

需要进行反汇编的常见情况包含以下几种：

- 分析恶意软件：通常，恶意软件的作者不会提供他们作品的源码（脚本蠕虫除外）。由于缺乏源码，要准确了解恶意软件的运行机制，我们的选择非常有限。动态分析和静态分析是分析恶意软件的两种主要技术。动态分析是指在严格控制的环境，比如沙盒中执行恶意软件，并使用系统检测实用工具记录其所有行为。静态分析则是试图通过浏览程序代码来理解程序的行为。此时，要查看的就是对恶意软件进行反汇编之后得到的源码清单。
- 漏洞分析：对一个软件进行安全审核的时候，我们可以将审核过程分为3步：发现漏洞、分析漏洞、开发破解程序。和分析恶意软件类似，如果有源码清单，这个过程会容易很多。
- 软件互操作性：如果厂商发布一个硬件时只为一种平台提供了驱动程序，那么假如我想创建其他平台的驱动，或是为该软件提供插件，那将非常困难。此时，静态代码分析是唯一的补救方法
- 编译器验证：编译器的用途是生成汇编语言，优秀的反汇编工具通常需要验证编译器是否符合设计规范。除了准确性外，分析人员还可以从中寻找优化编译器的机会，查知编译器是否容易被攻破，以至于可以在其生成的代码中插入后门等。



那么，一个实用的、强大的代码逆向工具应该包含哪些功能呢？我认为至少应该包含如下功能

- 基本的反汇编能力：将二进制程序转换为汇编代码/源代码
- 容错能力：允许用户可交互式地修正反汇编的结果
- 调试程序的能力：能以源码形式调试程序
- 多视图：从数据、代码、调用关系等多个角度提供信息给用户
- 可编程：提供内置脚本和编程语言给用户使用
- 可扩展：允许用户基于其部件进行二次开发/插件开发



IDA 是怎么满足这些需求的呢？请看

## 反汇编

要理解 IDA 是如何拥有如此强大的反汇编能力（机器码->汇编->C 源码），就要先对基础反汇编（机器码->汇编）的手段有一定的理解。

想象一个反汇编任务：对于一个100 KB 的 ELF 可执行文件，请区分其中的的代码与数据，并把代码转换成汇编语言显示给用户，在整个过程中，不要遗漏任何信息。要完成这样的任务，一个基本的反汇编算法是这样的：、

1. 第一步，确定反汇编的代码区域。通常，指令与数据混杂在一起，区分它们就非常重要。
2. 第二步，知道指令的起始地址后，下一步就是读取该地址，执行一次表查找，将二进制操作码的值和它的汇编语言助记符对应起来。
3. 第三步，获取指令并解码任何所需的操作数后，需要对它的汇编语言等价形式进行格式化，输出其反汇编代码。
4. 第四步，输出一条指令后，继续反汇编下一条指令，并重复上述过程，直到反汇编完文件中的所有指令。

有大量的算法可以用于确定从何处开始反汇编、如何选择下一条反汇编的指令、如何区分代码和数据，以及如何确定何时完成对最后一条指令的反汇编。线性扫描（linear sweep）和递归下降（recursive descent）是两种常用的反汇编算法。



### 线性扫描算法

线性扫描算法采用一种非常直接的方法来确定需要反汇编的指令的位置：一条指令结束的地方、另一条指令开始的地方。因此，确定起始位置最为困难。常用的解决办法是，假设程序中的代码节所包含的全部都是机器码。反汇编从一个代码段的第一个字节开始，以线性模式扫描整个代码段，逐条反汇编每条指令，直到完成整个代码段。这种算法并不会通过识别分支等非线性指令来了解程序的控制流。

线性扫描算法的主要优点在于：它能够完全覆盖程序的所有代码段。线性扫描算法的主要缺点在于：它没有考虑到代码中可能混有数据，比如，编译器在编译 switch 语句时选择在函数本身中嵌入一个跳转表时，线性扫描算法会将这个跳转表也转换成指令，而这是完全错误的。

Objdump，GNU 的 GDB 和微软的 WinDbg 的反汇编引擎均采用线性扫描算法。所以在其中也不含有控制流的概念。



### 递归下降算法

递归下降算法采用另一种不同的方式来定位指令：递归下降算法重视控制流的概念，控制流根据一条指令是否被另一条指令引用来决定是否对其进行反汇编。下面根据指令类别分别介绍如何处理

- 顺序流指令：顺序流指令将执行权传递给紧随其后的下一条指令。顺序流指令包括算术指令，如 add；寄存器与内存之间的传输指令，如 mov；栈操作指令，如 push。这些指令的反汇编过程以线性扫描方式进行。
- 条件分支指令：条件分支指令，如 x86 的 jnz 指令，会提供两条可能的执行路径。由于无法在静态分析时确定条件测试的结果，所以递归下降算法会反汇编两条路径，同时，将分支目标的地址添加到稍后 TODO 的列表里，推迟分支目标指令的反汇编过程。
- 无条件分支指令：与顺序流指令一样，无条件分支指令会将执行权传递给跳转目标指令，所以紧跟在无条件分支指令后的代码将不会被反汇编。递归下降算法会尝试确定无条件跳转的目标，并将目标地址添加到稍后 TODO 的列表里。但是如果跳转目标是一个运行时的值，比如 jump eax，那就无法确定跳转目标了。
- 函数调用指令：函数调用指令的运行方式与无条件跳转指令非常相似，包括无法确定 call eax 等指令的目标。唯一不同的地方在于，一旦函数结束，执行权将返回给紧跟在 call 指令后的那条指令。在这方面，它们与条件分支指令类似，因为它们都生成了两条指令路径。call 的目标地址被添加到稍后 TODO 的列表里，而紧跟在 call 指令后的指令则以线性扫描方式进行反汇编。需要注意，从被调用函数返回时，如果返回值被故意篡改，那么就不会返回到 call 指令的下一条指令，在这种情况下，递归下降算法会失败（线性扫描算法也会失败）。
- 返回指令：由于实际执行时，返回指令会从运行时的栈顶/寄存器中取返回地址并跳转，但静态分析时没有这些信息，所以递归下降算法会从稍后 TODO 的列表里取出一条进行反汇编。

递归下降算法的主要优点在于，它具有区分代码与数据的能力。递归下降算法的主要缺点，在于它无法处理间接代码路径，如利用指针表来查找目标地址的跳转和调用。然而，通过采用一些用于识别指向代码的指针的启发式算法，递归下降算法能够提供所有代码，并清楚地区分代码与数据。

IDA Pro 就是一种典型的递归下降反汇编器，其中也使用了大量启发式算法和工程 trick 来弥补递归下降算法。



## 容错

在介绍反汇编时提到，无论是线性扫描还是递归下降算法都有缺陷，所以像 Objdump，Windbg 等软件都存在一些失效的例子，IDA Pro 与它们不同的一点在于，IDA Pro 给用户提供了大量机会来指导和推翻它的决定。只要最终的结果能变成准确的结果，那么这就是最好的结果。



交互式的纠错方式如下：

- 注释和宏：编译时源代码里的注释会被忽略，宏定义会被展开
  - IDA Pro 允许用户配置宏定义并导入汇编代码中，同时也允许用户给汇编代码添加注释，以便于更好理解程序含义。

- 数据转换：在汇编代码->C 源码的过程中，需要确定数据类型
  - 通过了解寄存器的使用方式，可以推断出数据类型，比如一条指令从内存加载了一个32位寄存器，可以据此推断出相关内存位置保存有一个4字节的数据类型（虽然无法判断它是一个4字节整数，还是4字节指针）。
  - 函数原型可以用于为函数参数分配数据类型。为此，IDA Pro 维护了一个庞大的函数原型库，这样就可以对函数参数的类型进行分析，并且尝试将参数与某个内存位置关联起来，即从callee 处反推 caller 的数据类型。
  - 分析字节序列可以知道可能的数据类型，比如发现较长的 ASCII 字符序列，即可认为他们属于字符数组。
  - IDA Pro 允许用户对反编译出的 C 源码进行修正，比如变量重命名、变量类型修改、重新导入结构体类型等

- 数据与代码互相转换：在自动分析阶段，字节有可能被错误地归类。数据字节可能被错误的归类为代码字节，并被反汇编成指令；而代码字节可能被错误地归类为数据字节，并被格式化成数据值。有许多原因会导致这类情况，如一些编译器将数据嵌入在程序的代码部分，或者一些代码字节从未被作为代码直接引用。
  - 因而 IDA Pro 选择不对它们进行反汇编，而是交给用户自行选择。



## 多视图

IDA Pro 提供了多种视图帮助用户进行分析，包括

- 控制流视图
- 伪代码视图
- 交叉引用图
- 导入/导出表
- 字符串表
- 函数列表
- ……



## 调试

IDA Pro 提供了一个功能强大的调试器，我认为最好的两个功能分别是反-反调试和远程调试。

- 反-反调试：程序的开发者（尤其是病毒的开发者）往往不希望逆向人员对程序进行调试，所以往往会使用一些反调试技术，例如新开线程检测调试器进程的存在，如果检测到就强制结束程序等。IDA Pro 的调试器允许用户对上了反调试技术的程序进行解密和解压循环、重建导入表、隐藏调试器进程、处理异常等操作，从而实现反-反调试。

- 远程调试：IDA Pro 允许用户在本地开启一个 IDA server，然后调试一个远程程序。由于 IDA Pro 对文件类型的支持性很广，所以用户可以在 windows 系统上调试一个 linux 程序，IDA Pro 内部实现了一套模拟器来支持跨系统的调试。



## 可编程

IDA 内置了一套编程语言 IDC，可以用于对程序进行动态地址计算、去模糊、打补丁等操作。IDC 的用途更多是写一个针对性脚本，而不是一个通用性插件。



## 可扩展

IDA Pro 提供了一套 C++ 风格的 SDK 给用户进行编程和扩展，SDK 是 IDC 的底层支持，并且，不是所有的 SDK 都有对应的 IDC 封装，其功能比 IDC 更加强大



## IDA Pro 的设计哲学

总的来看，IDA Pro 自1991年出现雏形，到2000年后成为最受欢迎也最为强大的逆向软件，其设计哲学是一以贯之的：

- Nothing beats human brain：强调人的重要性，一秒钟的正确灵感胜过数百年的处理时间，为此，IDA Pro 提供了尽可能多的交互性。实际上，反汇编中的任何内容都可以被修改、操纵、重新排列或重新定义。
- Time is the essence：汇编语言向导只看几个操作码就掌握程序目的的日子已经一去不复返了。今天的病毒和蠕虫通常是用高级语言编写的。由于独特的 FLIRT 技术和先进的堆栈跟踪功能，IDA Pro 的反编译尽可能接近原始源代码。
- Static disassembly is limited：仅仅静态反编译并不能说明全部情况。加密或混淆代码经常出现在当今的恶意代码中；弄清代码和数据之间的确切区别是一门艺术，而不是一门科学。